import type { ObjectNode, RefsStore } from '@vinejs/compiler/types';
import { type ObjectGroup } from './group.js';
import { BaseType } from '../base/main.js';
import { type GroupConditional } from './conditional.js';
import { type OTYPE, type COTYPE, PARSE, UNIQUE_NAME, IS_OF_TYPE, type ITYPE } from '../../symbols.js';
import type { Validation, SchemaTypes, FieldOptions, ParserOptions } from '../../types.js';
/**
 * Converts schema properties to camelCase during validation.
 * This is a wrapper around VineObject that automatically converts
 * property names from snake_case to camelCase in the output.
 *
 * @template Schema - The underlying VineObject schema type
 *
 * @example
 * const schema = vine.object({
 *   first_name: vine.string(),
 *   last_name: vine.string()
 * }).camelCase()
 *
 * // Output will have: { firstName: string, lastName: string }
 */
export declare class VineCamelCaseObject<Schema extends VineObject<any, any, any, any>> extends BaseType<Schema[typeof ITYPE], Schema[typeof COTYPE], Schema[typeof COTYPE]> {
    #private;
    /**
     * Unique name identifier for union type resolution
     */
    [UNIQUE_NAME]: string;
    /**
     * Type checker function to determine if a value is an object.
     * Required for "unionOfTypes" functionality.
     *
     * @param value - The value to check
     * @returns True if the value is a non-null object and not an array
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    /**
     * Creates a new VineCamelCaseObject instance wrapping the given schema.
     *
     * @param schema - The VineObject schema to wrap with camelCase conversion
     */
    constructor(schema: Schema);
    /**
     * Clone object with camelCase conversion preserved.
     *
     * @returns A cloned instance of this VineCamelCaseObject schema
     */
    clone(): this;
    /**
     * Compiles the schema type to a compiler node with camelCase enabled.
     *
     * @param propertyName - Name of the property being compiled
     * @param refs - Reference store for the compiler
     * @param options - Parser options
     * @returns Compiled object node with camelCase conversion
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ObjectNode;
}
/**
 * VineObject represents an object value in the validation schema.
 * It validates objects with predefined properties, supports conditional
 * groups, and provides control over unknown properties.
 *
 * @template Properties - Record of property names to their schema types
 * @template Input - The expected input type for this object
 * @template Output - The output type after validation and transformation
 * @template CamelCaseOutput - The output type with camelCase property names
 *
 * @example
 * const schema = vine.object({
 *   name: vine.string(),
 *   email: vine.string().email(),
 *   age: vine.number().min(0)
 * })
 *
 * const result = await vine.validate({
 *   schema,
 *   data: { name: 'John', email: 'john@example.com', age: 30 }
 * })
 */
export declare class VineObject<Properties extends Record<string, SchemaTypes>, Input, Output, CamelCaseOutput> extends BaseType<Input, Output, CamelCaseOutput> {
    #private;
    /**
     * Unique name identifier for union type resolution
     */
    [UNIQUE_NAME]: string;
    /**
     * Type checker function to determine if a value is an object.
     * Required for "unionOfTypes" functionality.
     *
     * @param value - The value to check
     * @returns True if the value is a non-null object and not an array
     */
    [IS_OF_TYPE]: (value: unknown) => boolean;
    constructor(properties: Properties, options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Returns a clone copy of the object properties. The object groups
     * are not copied to keep the implementations simple and easy to
     * reason about.
     */
    getProperties(): Properties;
    /**
     * Returns a clone copy of the cherry picked object properties including
     * only the mentioned properties.
     */
    pick<Keys extends keyof Properties>(keys: Keys[] | readonly Keys[]): Pick<Properties, Keys>;
    /**
     * Returns a cloned copy of the cherry picked object properties without
     * the mentioned properties
     */
    omit<Keys extends keyof Properties>(keys: Keys[] | readonly Keys[]): Omit<Properties, Keys>;
    /**
     * Copy unknown properties to the final output.
     */
    allowUnknownProperties<Value>(): VineObject<Properties, Input & {
        [K: string]: Value;
    }, Output & {
        [K: string]: Value;
    }, CamelCaseOutput & {
        [K: string]: Value;
    }>;
    /**
     * Merge a union to the object groups. The union can be a "vine.union"
     * with objects, or a "vine.object.union" with properties.
     */
    merge<Group extends ObjectGroup<GroupConditional<any, any, any, any>>>(group: Group): VineObject<Properties, Input & Group[typeof ITYPE], Output & Group[typeof OTYPE], CamelCaseOutput & Group[typeof COTYPE]>;
    /**
     * Clone object
     */
    clone(): this;
    /**
     * Applies camelcase transform
     */
    toCamelCase(): VineCamelCaseObject<this>;
    /**
     * Compiles the schema type to a compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): ObjectNode;
}
