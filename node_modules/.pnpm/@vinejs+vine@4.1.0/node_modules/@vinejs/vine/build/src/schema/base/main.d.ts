import Macroable from '@poppinss/macroable';
import type { RefsStore } from '@vinejs/compiler/types';
import { ITYPE, OTYPE, COTYPE, PARSE } from '../../symbols.js';
import type { Parser, Validation, RuleBuilder, FieldOptions, CompilerNodes, ParserOptions, ConstructableSchema, WithCustomRules } from '../../types.js';
import { ConditionalValidations } from './conditional_rules.js';
/**
 * Modifies the schema type to allow null values in addition to the
 * original schema type. This is useful for optional database fields
 * or API responses that may contain null values.
 *
 * @template Schema - The underlying schema type to modify
 *
 * @example
 * const schema = vine.string().nullable()
 * // Accepts: "hello", null
 * // Rejects: undefined, 123
 */
export declare class NullableModifier<Schema extends ConstructableSchema<any, any, any>> implements ConstructableSchema<Schema[typeof ITYPE] | null, Schema[typeof OTYPE] | null, Schema[typeof COTYPE] | null> {
    #private;
    /**
     * Define the input type of the schema, including null
     */
    [ITYPE]: Schema[typeof ITYPE] | null;
    /**
     * The output value of the field with null support.
     * The property points to a type only and not the real value.
     */
    [OTYPE]: Schema[typeof OTYPE] | null;
    [COTYPE]: Schema[typeof COTYPE] | null;
    /**
     * Creates a new nullable modifier wrapping the given schema.
     *
     * @param parent - The schema to make nullable
     */
    constructor(parent: Schema);
    /**
     * Mark the field under validation as optional. An optional
     * field allows both null and undefined values.
     *
     * @returns A new OptionalModifier wrapping this nullable schema
     */
    optional(): OptionalModifier<this>;
    /**
     * Creates a fresh instance of the underlying schema type
     * and wraps it inside the nullable modifier.
     *
     * @returns A cloned instance of this nullable modifier
     */
    clone(): this;
    /**
     * Compiles to compiler node by delegating to the parent schema
     * and setting the allowNull flag.
     *
     * @param propertyName - Name of the property being compiled
     * @param refs - Reference store for the compiler
     * @param options - Parser options
     * @returns Compiled compiler node with null support
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes;
}
/**
 * Modifies the schema type to allow undefined values in addition to the
 * original schema type. This is useful for form fields that may not be
 * present in the submitted data.
 *
 * @template Schema - The underlying schema type to modify
 *
 * @example
 * const schema = vine.string().optional()
 * // Accepts: "hello", undefined
 * // Rejects: null (unless also nullable), 123
 */
export declare class OptionalModifier<Schema extends ConstructableSchema<any, any, any>> extends ConditionalValidations implements ConstructableSchema<Schema[typeof ITYPE] | null | undefined, Schema[typeof OTYPE] | undefined, Schema[typeof COTYPE] | undefined>, WithCustomRules {
    #private;
    /**
     * Define the input type of the schema, including undefined and null
     */
    [ITYPE]: Schema[typeof ITYPE] | undefined | null;
    /**
     * The output value of the field with undefined support.
     * The property points to a type only and not the real value.
     */
    [OTYPE]: Schema[typeof OTYPE] | undefined;
    [COTYPE]: Schema[typeof COTYPE] | undefined;
    /**
     * List of validations to apply to non-undefined values
     */
    validations: Validation<any>[];
    /**
     * Creates a new optional modifier wrapping the given schema.
     *
     * @param parent - The schema to make optional
     * @param validations - Optional list of validations to apply
     */
    constructor(parent: Schema, validations?: Validation<any>[]);
    /**
     * Shallow clones the validations. Since, there are no API's to mutate
     * the validation options, we can safely copy them by reference.
     *
     * @returns Cloned array of validations
     */
    protected cloneValidations(): Validation<any>[];
    /**
     * Compiles validations into a format suitable for the validator compiler.
     *
     * @param refs - Reference store for tracking validation functions
     * @returns Compiled validation definitions
     */
    protected compileValidations(refs: RefsStore): {
        ruleFnId: `ref://${number}`;
        name: string;
        implicit: boolean;
        isAsync: boolean;
    }[];
    /**
     * Mark the field under validation to be null. The null value will
     * be written to the output as well.
     *
     * If `optional` and `nullable` are used together, then both undefined
     * and null values will be allowed.
     */
    nullable(): NullableModifier<this>;
    /**
     * Push a validation to the validations chain.
     */
    use(validation: Validation<any> | RuleBuilder): this;
    /**
     * Creates a fresh instance of the underlying schema type
     * and wraps it inside the optional modifier
     */
    clone(): this;
    /**
     * Compiles to compiler node
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes;
}
/**
 * The BaseType class abstracts the repetitive parts of creating
 * a custom schema type. It provides common functionality like validation
 * chaining, optional/nullable modifiers, and compilation logic.
 *
 * @template Input - The expected input type for this schema
 * @template Output - The output type after validation and transformation
 * @template CamelCaseOutput - The output type with camelCase field names
 *
 * @example
 * class CustomStringType extends BaseType<string, string, string> {
 *   [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions) {
 *     return { type: 'literal', name: propertyName, ... }
 *   }
 *   clone() { return new CustomStringType() }
 * }
 */
export declare abstract class BaseType<Input, Output, CamelCaseOutput> extends Macroable implements ConstructableSchema<Input, Output, CamelCaseOutput>, WithCustomRules {
    /**
     * Each subtype should implement the compile method that returns
     * one of the known compiler nodes for the validation engine.
     *
     * @param propertyName - Name of the property being compiled
     * @param refs - Reference store for the compiler
     * @param options - Parser options
     * @returns Compiled compiler node
     */
    abstract [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): CompilerNodes;
    /**
     * The child class must implement the clone method to create
     * a deep copy of the schema instance.
     *
     * @returns A cloned instance of this schema
     */
    abstract clone(): this;
    /**
     * Define the input type of the schema for TypeScript inference
     */
    [ITYPE]: Input;
    /**
     * The output value type of the field after validation.
     * The property points to a type only and not the real value.
     */
    [OTYPE]: Output;
    [COTYPE]: CamelCaseOutput;
    /**
     * Set of validations to run on the field value
     */
    protected validations: Validation<any>[];
    /**
     * Configuration options for this field
     */
    protected options: FieldOptions;
    /**
     * Creates a new BaseType instance with optional configuration.
     *
     * @param options - Field options like bail mode and nullability
     * @param validations - Initial set of validations to apply
     */
    constructor(options?: FieldOptions, validations?: Validation<any>[]);
    /**
     * Shallow clones the validations. Since, there are no API's to mutate
     * the validation options, we can safely copy them by reference.
     */
    protected cloneValidations(): Validation<any>[];
    /**
     * Shallow clones the options
     */
    protected cloneOptions(): FieldOptions;
    /**
     * Compiles validations
     */
    protected compileValidations(refs: RefsStore): {
        ruleFnId: `ref://${number}`;
        name: string;
        implicit: boolean;
        isAsync: boolean;
    }[];
    /**
     * Define a method to parse the input value. The method
     * is invoked before any validation and hence you must
     * perform type-checking to know the value you are working with.
     *
     * @param callback - Parser function to transform the input value
     * @returns This schema instance for method chaining
     *
     * @example
     * vine.string().parse((value) => {
     *   return typeof value === 'string' ? value.trim() : value
     * })
     */
    parse(callback: Parser): this;
    /**
     * Push a validation to the validations chain.
     *
     * @param validation - Validation rule or rule builder to add
     * @returns This schema instance for method chaining
     *
     * @example
     * vine.string().use(vine.createRule((value) => {
     *   return value.length > 0
     * }))
     */
    use(validation: Validation<any> | RuleBuilder): this;
    /**
     * Enable/disable the bail mode. In bail mode, the field validations
     * are stopped after the first error.
     *
     * @param state - Whether to enable bail mode
     * @returns This schema instance for method chaining
     */
    bail(state: boolean): this;
    /**
     * Mark the field under validation as optional. An optional
     * field allows both null and undefined values.
     *
     * @returns A new OptionalModifier wrapping this schema
     */
    optional(): OptionalModifier<this>;
    /**
     * Mark the field under validation to be null. The null value will
     * be written to the output as well.
     *
     * If `optional` and `nullable` are used together, then both undefined
     * and null values will be allowed.
     *
     * @returns A new NullableModifier wrapping this schema
     */
    nullable(): NullableModifier<this>;
}
