import { type RefsStore, type UnionNode } from '@vinejs/compiler/types';
import { UnionConditional } from './conditional.js';
import { ITYPE, OTYPE, COTYPE, PARSE } from '../../symbols.js';
import type { SchemaTypes, ParserOptions, ConstructableSchema, UnionNoMatchCallback } from '../../types.js';
import { VineOptional } from '../optional/main.js';
import { VineNull } from '../null/main.js';
/**
 * Vine union represents a union data type. A union is a collection
 * of conditionals and each condition has an associated schema
 */
export declare class VineUnion<Conditional extends UnionConditional<SchemaTypes>> implements ConstructableSchema<Conditional[typeof ITYPE], Conditional[typeof OTYPE], Conditional[typeof COTYPE]> {
    #private;
    [ITYPE]: Conditional[typeof ITYPE];
    [OTYPE]: Conditional[typeof OTYPE];
    [COTYPE]: Conditional[typeof COTYPE];
    constructor(conditionals: Conditional[]);
    /**
     * Mark the field under validation as optional. An optional
     * field allows both null and undefined values.
     */
    optional(): VineUnion<Conditional | UnionConditional<VineOptional<undefined>>>;
    /**
     * Mark the field under validation to be null. The null value will
     * be written to the output as well.
     *
     * If `optional` and `nullable` are used together, then both undefined
     * and null values will be allowed.
     */
    nullable(): VineUnion<Conditional | UnionConditional<VineNull>>;
    /**
     * Define a fallback method to invoke when all of the union conditions
     * fail. You may use this method to report an error.
     */
    otherwise(callback: UnionNoMatchCallback<Record<string, unknown>>): this;
    /**
     * Clones the VineUnion schema type.
     */
    clone(): this;
    /**
     * Compiles to a union
     */
    [PARSE](propertyName: string, refs: RefsStore, options: ParserOptions): UnionNode;
}
