import { createRule } from './create_rule.js';
import { SchemaBuilder } from '../schema/builder.js';
import { VineValidator } from './validator.js';
import { type ValidationError } from '../errors/validation_error.js';
import type { Infer, SchemaTypes, MetaDataValidator, ValidationOptions, ErrorReporterContract, MessagesProviderContact } from '../types.js';
/**
 * Main Vine class that provides a fluent API for creating validation schemas
 * and validating user input with type-safety using pre-compiled schemas.
 *
 * @example
 * const vine = new Vine()
 * const schema = vine.object({
 *   name: vine.string(),
 *   age: vine.number()
 * })
 * const result = await vine.validate({ schema, data: { name: 'John', age: 30 } })
 */
export declare class Vine extends SchemaBuilder {
    /**
     * Messages provider to use on the validator for internationalization
     * and custom error message formatting
     */
    messagesProvider: MessagesProviderContact;
    /**
     * Error reporter factory function to use on the validator for
     * formatting validation errors
     */
    errorReporter: () => ErrorReporterContract;
    /**
     * Control whether or not to convert empty strings to null during validation.
     * Useful for HTML form handling where empty inputs are submitted as empty strings
     */
    convertEmptyStringsToNull: boolean;
    /**
     * Collection of helper functions to perform type-checking or cast types
     * while keeping HTML forms serialization behavior in mind
     */
    helpers: {
        exists(value: any): boolean;
        isMissing(value: any): boolean;
        isTrue(value: any): boolean;
        isFalse(value: any): boolean;
        isString(value: unknown): value is string;
        isObject<Value>(value: unknown): value is Record<PropertyKey, Value>;
        hasKeys(value: Record<string, any>, keys: string[]): boolean;
        isArray<Value>(value: unknown): value is Value[];
        isNumeric(value: any): boolean;
        asNumber(value: any): number;
        asBoolean(value: any): boolean | null;
        asDayJS(value: any, format: import("../types.js").DateFieldOptions["formats"]): {
            dateTime: import("dayjs").Dayjs;
            formats: string | string[] | import("dayjs").FormatObject;
        };
        compareValues(inputValue: unknown, expectedValue: any): {
            isEqual: boolean;
            casted: unknown;
        };
        isEmail: typeof import("validator/lib/isEmail.js").default;
        isURL: typeof import("validator/lib/isURL.js").default;
        isAlpha: typeof import("validator").isAlpha;
        isAlphaNumeric: typeof import("validator").isAlphanumeric;
        isIP: typeof import("validator").isIP;
        isUUID: typeof import("validator").isUUID;
        isAscii: typeof import("validator").isAscii;
        isCreditCard: typeof import("validator").isCreditCard;
        isIBAN: typeof import("validator/lib/isIBAN.js").default;
        isJWT: typeof import("validator").isJWT;
        isLatLong: typeof import("validator").isLatLong;
        isMobilePhone: typeof import("validator").isMobilePhone;
        isPassportNumber: typeof import("validator").isPassportNumber;
        isPostalCode: typeof import("validator").isPostalCode;
        isSlug: typeof import("validator").isSlug;
        isDecimal: typeof import("validator").isDecimal;
        mobileLocales: import("validator/lib/isMobilePhone.js").MobilePhoneLocale[];
        postalCountryCodes: import("validator/lib/isPostalCode.js").PostalCodeLocale[];
        passportCountryCodes: readonly ["AM", "AR", "AT", "AU", "AZ", "BE", "BG", "BR", "BY", "CA", "CH", "CY", "CZ", "DE", "DK", "DZ", "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IN", "ID", "IR", "IS", "IT", "JM", "JP", "KR", "KZ", "LI", "LT", "LU", "LV", "LY", "MT", "MZ", "MY", "MX", "NL", "NZ", "PH", "PK", "PL", "PT", "RO", "RU", "SE", "SL", "SK", "TH", "TR", "UA", "US"];
        isULID(value: unknown): boolean;
        isHexColor: (value: string) => boolean;
        isActiveURL: (url: string) => Promise<boolean>;
        isDistinct: (dataSet: any[], fields?: string | string[]) => boolean;
        getNestedValue(key: string, field: import("@vinejs/compiler/types").FieldContext): any;
    };
    /**
     * Utility function to convert a validation function to a Vine schema rule
     */
    createRule: typeof createRule;
    /**
     * Pre-compiles a schema into a validation function for better performance
     * when validating multiple data sets against the same schema.
     *
     * @param schema - The validation schema to compile
     * @returns A compiled validator instance
     *
     * @example
     * const validate = vine.compile(schema)
     * await validate({ data })
     */
    compile<Schema extends SchemaTypes>(schema: Schema): VineValidator<Schema, Record<string, any> | undefined>;
    /**
     * Define a callback to validate the metadata given to the validator
     * at runtime. Useful for passing additional context like user IDs or permissions.
     *
     * @param callback - Optional validator function for metadata
     * @returns Object with compile method that accepts metadata type
     *
     * @example
     * const validate = vine.withMetaData<{ userId: string }>()
     *   .compile(schema)
     * await validate(data, { meta: { userId: '123' } })
     */
    withMetaData<MetaData extends Record<string, any>>(callback?: MetaDataValidator): {
        compile: <Schema extends SchemaTypes>(schema: Schema) => VineValidator<Schema, MetaData>;
    };
    /**
     * Validate data against a schema. Optionally, you can define
     * error messages, fields, a custom messages provider,
     * or an error reporter.
     *
     * @param options - Configuration object containing schema, data, and validation options
     * @returns Promise resolving to validated and typed data
     * @throws {ValidationError} When validation fails
     *
     * @example
     * await vine.validate({ schema, data })
     * await vine.validate({ schema, data, messages, fields })
     *
     * await vine.validate({ schema, data, messages, fields }, {
     *   errorReporter
     * })
     */
    validate<Schema extends SchemaTypes>(options: {
        /**
         * Schema to use for validation
         */
        schema: Schema;
        /**
         * Data to validate
         */
        data: any;
    } & ValidationOptions<Record<string, any> | undefined>): Promise<Infer<Schema>>;
    /**
     * Validate data against a schema without throwing the
     * "ValidationError" exception. Instead the validation
     * errors are returned within the return value.
     *
     * @param options - Configuration object containing schema, data, and validation options
     * @returns Promise resolving to tuple of [error, null] or [null, validatedData]
     *
     * @example
     * await vine.tryValidate({ schema, data })
     * await vine.tryValidate({ schema, data, messages, fields })
     *
     * await vine.tryValidate({ schema, data, messages, fields }, {
     *   errorReporter
     * })
     */
    tryValidate<Schema extends SchemaTypes>(options: {
        /**
         * Schema to use for validation
         */
        schema: Schema;
        /**
         * Data to validate
         */
        data: any;
    } & ValidationOptions<Record<string, any> | undefined>): Promise<[ValidationError, null] | [null, Infer<Schema>]>;
}
